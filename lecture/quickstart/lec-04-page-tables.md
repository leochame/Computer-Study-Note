# Lec 04 Page tables



## Preparation



页表是操作系统为每个进程空间提供专用空间和地址的机制。页表确定内存地址含义，以及可以访问的物理内存部分。他们允许xv6隔离不同进程的地址空间，并将它们复用到单个物理内存上。  &#x20;

> xv6 也进行了一些巧妙操作：在多个地址空间中映射相同的内存（一个跳板页），并通过未映射页保护内核和用户堆栈。
>
> 在多个地址空间中映射相同的内存（一个跳板页）是一种技术，通过它可以在操作系统中为不同的进程提供相同的内存区域。这种技术允许操作系统在多个进程的地址空间中共享一段物理内存，而无需为每个进程单独分配新的物理内存。
>
> 跳板页（trampoline page）通常用于上下文切换过程。在上下文切换中，操作系统需要保存和恢复进程的状态。通过在内核和用户态之间共享跳板页，可以简化这种转换过程。



### 一、分页硬件

RISC-V指令（用户态和内核态）都是操作虚拟地址。机器的RAM（即物理内存，临时存储器），通过物理地址进行索引。RISC-V的页表硬件所做的事情就是，将每个虚拟地址映射到物理地址上。

> **以S 39 RISC-V** 架构中的虚拟地址到物理地址的转换过程为例子，讲解一下这个是怎么运行的：
>
> 1.首先我们要知道，Sv39 是 RISC-V 架构中的一种地址映射方式，它支持 64 位虚拟地址，其中 **只有底部的 39 位** 被用于虚拟地址的实际映射，**顶部的 25 位** 是没有用的。因此，虚拟地址的前 25 位被忽略，只有底部的 39 位会参与地址转换。
>
> RISC-V 页表其实是一个【2^27】个的页表项（page table entries , PTEs），每个PTE由44 bits的物理页表号码（PPN）和 10 bits的 flags 组成。  &#x20;
>
> 分页硬件会将这39位中的 top 27 bits 去页表中寻找到页表项（PTE），然后制造出一个 56 bit的物理地址。
>
> 这56位的top 44 bits 来自 PTE的PPN， bottom 12 bits 则是复制来自原始虚拟地址。
>
> 页表让操作系统以【2^12】 bytes 的对齐 chunks 的粒度控制虚拟地址到物理地址的转换。这样的chunks称为**Page**。
>
>

<figure><img src="../../.gitbook/assets/image (5).png" alt="" width="301"><figcaption><p>Page Table</p></figcaption></figure>

**RISC-V CPU** 将 **虚拟地址** 转换为 **物理地址** 的时，使用了一个类似B+树+字典树的 **三层树结构** 来存储 **页表**。

* 在这种三层树结构中，页表的每一层存储了指向下一层页表的物理地址，直到最后一层，这些页表项（PTE）最终指向物理页。
* **根页表**：根页表位于物理内存中，是一个 4096 字节（即 4KB）的页面，包含 512 个 **PTE**。这些 PTE 指向树中下一层的页表。
* **第二层和第三层页表**：每一层的页表也包含 512 个 PTE，最终指向 **物理页**。

那么是如何使用虚拟地址的27位查找的呢？

* 虚拟地址的 **前 9 位** 用于在根页表中查找一个 PTE。
* **中间的 9 位** 用于在第二层的页表中查找一个 PTE。
* **底部的 9 位** 用于在第三层的页表中查找一个 PTE。

如果三个PTE任意一个不存在，分页硬件就会触发故障，由内核处理。

<figure><img src="../../.gitbook/assets/image (6).png" alt="" width="375"><figcaption><p>RISC-V address translation details.</p></figcaption></figure>

要告诉CPU使用页表，内核必须将根页表的物理地址写入satp寄存器。随后指令生成的所有地址都将通过页表（被该 `satp` 寄存器指向的）进行转换。每个 CPU 都有自己的 `satp`，因此不同的 CPU 可以运行不同的进程，每个进程都有由其页表描述的私有地址空间。

反引用地址的指令（如加载、存储、跳转和函数调用）仅使用虚拟地址，然后分页硬件将虚拟地址翻译成物理地址，再发送到 RAM 硬件以读取或写入存储。



### 二、内核地址空间

还有一个描述内核地址空间的页表。内核配置其地址空间布局，以便在可预测的虚拟地址下访问物理内存和各种硬件资源。

内核使用“直接映射”访问RAM和内存映射设备寄存器，即在虚拟地址等于物理地址的地址处映射资源。

有几个内核虚拟地址不是直接映射的,一个是跳板页，一个是内核栈页。

一是**trampoline页**，它被映射到虚拟地址空间的顶端，用户和内核的页表里都有这一项映射，摆放的位置相同，很快我们将在下一章介绍这一页的作用。trampoline页被映射了两次，一次映射到虚拟地址空间的顶端，一次是直接映射（trampoline页位于RAM中）。

二是**内核栈**，

* 每个进程都有其独立的内核栈，用于存储内核在执行该进程时使用的局部变量、返回地址等信息。更准确地说，每个进程在用户空间执行指令时使用的是用户栈，而在内核空间下执行时（一般称为这个用户进程的内核线程）使用的是内核栈，xv6内核是C代码，自然需要内核栈来保存关于函数调用等信息。内核栈是一页页地被分配的，从靠近PHYSTOP的位置开始往下分配。因此这些内核栈也在RAM当中，自然会被直接映射到内核的虚拟地址空间里。现在我们再一次将这些内核栈映射到内核虚拟地址空间的高地址部分，这样就可以自然地在它们之间插入一些保护页guard page(在每个内核栈的下方，xv6 预留了一个未映射的保护页)。
* 保护页的PTE\_V是unInvaliable，访问它会引发缺页错误的异常，从而陷入内核，这样的设计可以防止内核栈溢出。同样地，内核栈也被映射了两次，但是如果只使用直接映射的方式，而仍要保留这些保护页，那么分布于[内核栈](https://zhida.zhihu.com/search?content_id=166273945\&content_type=Article\&match_order=11\&q=%E5%86%85%E6%A0%B8%E6%A0%88\&zhida_source=entity)之间的那些保护页会浪费一些物理内存。
* **优先崩溃  and 异常处理**：
  * 如果内核栈溢出并试图访问保护页，由于保护页的 PTE 是无效的，这会导致系统抛出异常并使内核进入 panic 状态。
  * 这种设计是为了防止栈溢出覆盖其他关键的内核内存区域，从而导致不正确的操作\




```
// Some code
| 31-12                           | 11-9  |   8-6  | 5   | 4   | 3   | 2        | 1     | 0    |
|---------------------------------|-------|--------|-----|-----|-----|----------|---=---|------|
| Physical Page Address (20 bits) | Avail | Global | U/S | PWT | PCD | Accessed | Dirty | Valid |

```





## 三、Code: creating an address space

#### 核心数据结构

* **`pagetable_t:`** 是一个指向 RISC-V 根页表页的指针。它可能是内核页表，或者是每个进程的页表之一。

#### 关键函数

* **`walk:`** 查找虚拟地址的页表项（PTE）。它模仿RISC-V硬件的页表遍历。
* **`mappages:`** 为新的映射安装页表项。它调用 `walk` 来查找每个虚拟地址的PTE，并初始化PTE。

#### 初始化过程

1. **`kvminit:`** 在启动序列的早期被 `main` 调用，用于创建内核页表。
2. **`kvmmake:`** 在 `kvminit` 中调用，分配一个页的物理内存来保存根页表页，然后调用 `kvmmap` 安装所需的内核翻译。
3. **`kvmmap:`** 调用 `mappages` 将一系列虚拟地址映射到相应的一系列物理地址。它为每个虚拟地址分别执行此操作。

#### 地址翻译

* **`walk:`** 递归地查找PTE，必要时分配新的页表页并更新PTE。每层使用9位虚拟地址索引到相关页目录页。
* **直接映射:** 依赖于物理内存直接映射到内核虚拟地址空间。例如，`walk` 在遍历页表时，使用PTE中的物理地址作为虚拟地址来获取下一层的PTE。

#### 特殊函数与机制

* **`kvminithart:`** 由 `main` 调用来安装内核页表。它将根页表页的物理地址写入寄存器 `satp`，使得CPU使用内核页表翻译地址。
* **TLB 缓存与刷新:**
  * **`sfence.vma:`** 是一条用于刷新当前CPU的TLB的指令。在 `kvminithart` 中被调用，以确保地址翻译的一致性和安全性。
  * 当更改页表时，必须告知CPU使对应的缓存TLB条目无效，以防止使用旧的缓存映射。

#### 系统调用数据传输

* **`copyout` 和 `copyin:`** 用于在用户虚拟地址和物理内存之间复制数据。它们在 `vm.c` 中，因为需要显式翻译虚拟地址。

#### 启动和初始化

* 在启动序列的早期， `main` 调用 `kvminit` 来创建内核的页表。在这一过程中， `kvmmake` 首先分配根页表页，然后调用 `kvmmap` 安装内核所需的地址翻译。
* `proc_mapstacks` 为每个进程分配一个内核栈，并调用 `kvmmap` 来映射栈的虚拟地址。

#### 地址空间标识符（ASID）

* 为了避免刷新整个 TLB，RISC-V CPU 可能支持地址空间标识符（ASID）。虽然 xv6 不使用此功能，但它允许内核仅刷新特定地址空间的 TLB 条目。

#### 示例过程

* `kvminithart` 安装内核页表，并写入根页表页的物理地址到寄存器 `satp`。
* `sfence.vma` 用于刷新当前 CPU 的 TLB，以确保所有页面表更改都生效并且没有使用旧的缓存映射。





## 三、Code: exec



&#x20;**内存布局示例：**

假设你有一个简单的程序，其中包含一个文本段（代码段）和一个数据段，内存中的布局可能如下所示：

```
+-------------------------+
| 代码段 (Text Segment)   | <- 虚拟地址 0x0000 (程序的起始地址)
+-------------------------+
| 空白区域（可能是BSS等）  |
+-------------------------+
| 数据段 (Data Segment)   | <- 虚拟地址 0x1000 (数据段的起始地址)
+-------------------------+
| 堆栈段 (Stack Segment)  | <- 虚拟地址（通常位于较高地址）
+-------------------------+
```

在这个布局中：

* **`0x0000`** 是程序的起始地址，通常用于 **文本段**，即程序的可执行代码。这是因为操作系统通常将代码加载到内存的最底部。通常是只读。它在内存中的位置通常是从 **`0x0000` 开始**，即从虚拟地址的起始位置开始加载。
* **`0x1000`** 是 **数据段** 的起始地址，它位于第二个 4KB 页面（即第一个页面后）。这个地址符合内存对齐要求，使得操作系统和硬件能高效地管理内存。可读可写，但是会要求对齐4KB
* **栈段** 和 **堆段** 则位于内存的其他部分，栈通常位于高地址，堆段则在中间。



### exec 系统调用怎么加载和初始化应用程序?

#### 1. **ELF 文件的内存映射：**

ELF 文件（可执行与可链接格式，Executable and Linkable Format）是一个程序的二进制文件格式。这个文件格式包含了程序的代码、数据以及一些控制信息。`filesz` 表示程序段在文件中的大小。`memsz` 表示程序段在内存中的大小。

如果 `filesz` 小于 `memsz`，这意味着程序段在内存中有一部分是空的，需要用零填充。这是因为 **`memsz`** 可能包括了程序中 **未初始化的全局变量**，而这些变量的值会在程序加载时被填充为零。

#### 2. **栈的初始化：**

当程序通过 `exec` 启动时，它的栈需要被初始化。栈用于存放程序的函数调用信息、局部变量、以及程序参数。

* `exec` 为用户栈分配一个页面（4KB）。
* `exec` 会将程序的参数（如命令行参数）逐个复制到栈的顶部，并将它们的指针记录在一个叫做 `ustack` 的位置。这些指针组成了 `argv`（程序的参数列表）。
* `exec` 在栈顶加一个空指针，以便 `main` 函数能够正确地读取参数列表。
* 程序的参数个数 `argc` 和参数列表 `argv` 会通过系统调用的返回路径传递给 `main`。具体来说：
  * `argc` 通过系统调用返回值传递，放在 `a0` 寄存器中。
  * `argv` 通过 `trapframe` 中的 `a1` 寄存器传递。

#### 3. **栈下方的不可访问页面：**

* `exec` 会在栈页面的下方放置一个 **不可访问的页面**。
  * 栈页面下方的这个不可访问页面会用来检查程序是否尝试使用超过一页的栈。如果程序试图使用多个栈页面，它会触发页面错误（**page fault**），从而终止程序。
  * 另外，这个不可访问页面还会帮助 `exec` 处理过大的程序参数。如果程序的参数过大，`exec` 在将参数复制到栈时会发现目标页面不可访问，从而触发错误返回 `-1`。

#### 4. **错误处理和内存清理：**

在 `exec` 系统调用中，如果遇到错误（例如，程序段无效），它会：

* 跳转到 **`bad`** 标签，释放新分配的内存。
* 返回 `-1` 表示失败。

**注意：** `exec` 只有在成功创建了新的内存镜像后，才会释放旧的内存镜像。这样做是为了避免在错误发生时，程序的内存被清除，导致无法正确返回错误。

#### 5. **安全性检查：**

`exec` 的风险之一是，用户可以通过构造恶意的 ELF 文件，指定一些特定的地址，这些地址可能指向内核的空间（或者其他不应该访问的地方）。为了避免这种风险，xv6 做了一些安全检查。

例如：

* `if (ph.vaddr + ph.memsz < ph.vaddr)` 用来检查地址是否溢出。因为 `vaddr` 是虚拟地址，`memsz` 是内存段的大小，`vaddr + memsz` 必须大于 `vaddr`，否则会发生溢出，可能导致程序访问到不该访问的内存区域。

这种溢出的风险很大，假设用户故意构造一个 ELF 文件，使得 `vaddr + memsz` 溢出到一个看似合法的地址（如 `0x1000`），那么程序可能会访问到内核的内存空间。这对于内核来说是非常危险的，可能导致 **信息泄露、崩溃，甚至是安全漏洞**。

> 在 **xv6 的 RISC-V 版本** 中，这种问题没有发生，因为内核和用户空间的内存是分开的，内核有自己的独立页表，用户程序无法直接访问内核的内存。





## LAB

### Speed up system calls ([easy](https://pdos.csail.mit.edu/6.828/2024/labs/guidance.html))

创建个缓存，不用每次获取pid都要切换用户态和内核态（eliminates the need for kernel crossings when performing these system calls）。

页表的形式管理虚拟内存，加一页，页的映射，存放用户态和内核态的共享数据。



### Print a page table ([easy](https://pdos.csail.mit.edu/6.828/2024/labs/guidance.html))

仿照 \` freewalk()\`，遍历打印输出页表

每层遍历输出va,pte,pa。 不能理解这个va是什么，怎么产生的。

```c
#ifdef LAB_PGTBL
void
vmprint(pagetable_t pagetable) {

  printf("pagetable %p\n", pagetable);
  print_page(pagetable,2,SIGN_EXTEND(0));
  return;
}
#endif

void
print_page(pagetable_t pagetable, int level, uint64 base) {
  // todo your code here
  // there are 2^9 = 512 PTEs in a page table.
  for(int i = 0; i < 512; i++){
    pte_t pte = pagetable[i];
    if((pte & PTE_V) == 0){
      continue;
    }
    uint64 va = base + ((uint64)-i << PXSHIFT(level));

    uint64 pa = PTE2PA(pte);

    print_indent(level);
    printf("..%p: pte %p pa %p\n", (void*)va, (void*)pte, (void*)pa);


      // this PTE points to a lower-level page table.
      uint64 child = PTE2PA(pte);
    // 如果 PTE 指向下级页表，则递归打印
    if (pte & PTE_V) {
      if (level > 0) {
        print_page((pagetable_t)child, level - 1,va);
      }
    }
  }
}

void print_indent(int level) {
  for (int i = level; i < 2; i++) {
    printf(".. ");
  }
}
```





