# Lec 01: Introduction and Examples

## LEC 01 <a href="#tst9g" id="tst9g"></a>

### (一) **Preparation**: [Read chapter 1](https://pdos.csail.mit.edu/6.S081/2024/xv6/book-riscv-rev4.pdf) <a href="#gk6yu" id="gk6yu"></a>

#### 1. Memory And Process <a href="#l71eq" id="l71eq"></a>

* **系统调用返回值**：如果没有错误，系统调用返回 0；如果有错误，返回 -1。
* **fork 系统调用**：创建一个新进程，返回新进程的 PID。在父进程中，fork 返回新进程的 PID；在子进程中，fork 返回 0。`fork` 函数在父进程、子进程中都返回（一次调用两次返回）。
* **exit 系统调用**：使调用进程停止执行并释放资源（ 诸如内存和打开文件在内的资源 ），接受一个整数状态参数，0 表示成功，1 表示失败。
* **wait 系统调用**：返回已退出（或被杀死）的子进程的 PID，并将子进程的退出状态复制到传递给 wait 的地址。如果没有子进程退出，wait 将等待；如果没有子进程，wait 立即返回 -1。
* **父子进程输出顺序**：父进程和子进程的输出顺序可能不同，取决于谁先到达 printf 调用。
* **独立内存和寄存器**：父进程和子进程具有独立的内存和寄存器，更改一个进程中的变量不会影响另一个。
* **exec 系统调用**： 系统调用 `exec` 将从某&#x4E2A;_&#x6587;件_（通常是可执行文件）里读取内存镜像，并将其替换到调用它的进程的内存空间。

```
char *argv[3];
argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");
```

xv6 shell 用以上调用为用户执行程序 ，步骤如下：

1. 主循环通过 `getcmd` 读取命令行的输入，然后它调用 `fork` 生成一个 shell 进程的副本。
2. 父 shell 调用 `wait`，而子进程执行用户命令。

举例来说，用户在命令行输入“echo hello”：

1. `getcmd` 会以 `echo hello` 为参数调用 `runcmd`（7906）, 由 `runcmd` 执行实际的命令。
2. 对于 `echo hello`, `runcmd` 将调用 `exec` 。
3. 如果 `exec` 成功被调用，子进程就会转而去执行 `echo` 程序里的指令。
4. 在某个时刻 `echo` 会调用 `exit`，这会使得其父进程从 `wait` 返回。

#### 2. I/O and File descriptors <a href="#tst7x" id="tst7x"></a>

文件描述符是一个整数，代表一个由内核管理的对象，进程可以通过它进行读写操作。

read 和 write 系统调用从文件描述符命名的打开文件中读取字节并写入字节。调用 `read(fd, buf, n)` 从文件描述符 fd 中读取最多 n 个字节，将它们复制到 buf 中，并返回读取的字节数。

每个引用文件的文件描述符都有一个关联的偏移量。read 从当前文件偏移量读取数据，然后将该偏移量增加读取的字节数。

**IO 重定向**

重定向实现：通过使用 fork 和 exec 系统调用，shell 可以在不影响主进程 I/O 设置的情况下，重定向子进程的 I/O。例如，通过关闭标准输入文件描述符（0），然后打开一个新的文件，新的文件描述符将被分配为 0，从而实现输入重定向。

```
char *argv[2];
argv[0] = "cat";
argv[1] = 0;
if(fork() == 0) {
    close(0);
    open("input.txt", O_RDONLY);
    exec("cat", argv);
}
```

fork 和 exec 分开调用的好处在于，shell 可以在这两者之间重定向子进程的输入输出，而不会影响主 shell 的输入输出设置。如果把这两个调用合并成一个叫 forkexec 的系统调用，进行 I/O 重定向就会变得很麻烦。shell 可能需要在调用 forkexec 之前修改自己的 I/O 设置，然后再撤销这些修改；或者 forkexec 需要接受 I/O 重定向的指令作为参数；或者每个程序（比如 cat）都需要自己处理 I/O 重定向。这样做都不太方便。

#### 3. pipe <a href="#u2szz" id="u2szz"></a>

管道是一个小的内核缓冲区，通过一对文件描述符暴露给进程，一个用于读取，一个用于写入。将数据写入管道的一端会使这些数据可以从管道的另一端读取。管道提供了一种进程间通信的方式。

以下示例代码运行程序 wc，并将标准输入连接到管道的读取端：

```
int p[2]; // 声明一个整型数组 p，用于存储管道的两个文件描述符
char *argv[2]; // 声明一个字符指针数组 argv，用于存储传递给 wc 程序的参数
argv[0] = "wc"; // 设置 argv[0] 为 "wc"，表示要执行的命令
argv[1] = 0; // 设置 argv[1] 为 0（即 NULL），表示参数结束
pipe(p); // 创建一个管道，将读取端分配给 p[0]，写入端分配给 p[1]
/**
*操作系统会创建一个新的子进程。此时的执行流程会分成两个分支：
*父进程：fork() 返回子进程的 PID（非零值），执行 else 块内的代码。
*子进程：fork() 返回 0，执行 if 块内的代码。
*/
if(fork() == 0) { 
    close(0); // 关闭标准输入（文件描述符 0）
    dup(p[0]); // 将管道的读取端复制到标准输入（文件描述符 0）
    close(p[0]); // 关闭管道的读取端，因为它已经被复制到标准输入
    close(p[1]); // 关闭管道的写入端，因为子进程不需要写入数据
    exec("/bin/wc", argv); // 用 wc 程序替换当前进程，并传递参数
} else { // 父进程
    close(p[0]); // 关闭管道的读取端，因为父进程不需要读取数据
    write(p[1], "hello world\n", 12); // 向管道的写入端写入 "hello world\n"
    close(p[1]); // 关闭管道的写入端，表示写入结束
}
```

当管道中没有数据可读的时候，读取操作会阻塞（等待数据写入或者指向写入端的文件描述符关闭）。所有指向写入端的文件描述符被关闭，读操作会返回 0，标识数据流的结束。

**读取等待：**&#x5F53;管道中没有数据可读时，读取操作会阻塞，等待数据被写入或者所有指向写入端的文件描述符被关闭。

**返回 0：**&#x5982;果所有指向写入端的文件描述符都被关闭，读取操作会返回 0，这表示数据流的结束，就像读取到文件末尾一样。

**阻塞读取**：读取操作会一直阻塞，直到确定不会有新数据到达。这是为了确保读取操作能够正确处理数据流的结束。

**关闭写入端**：在执行 wc 程序之前，子进程需要关闭管道的写入端。如果不关闭，wc 程序的某个文件描述符可能会指向管道的写入端，这样 wc 就永远不会检测到文件结束符（EOF），导致程序无法正常结束。

**XV6 实现**

xv6 通过创建两个子进程来执行管道的左右两侧命令，并通过管道将它们连接在一起。左侧命令的输出被传递到右侧命令的输入。

```
  case PIPE:
    pcmd = (struct pipecmd*)cmd;
    if(pipe(p) < 0)
      panic("pipe");
    if(fork1() == 0){
      close(1);
      dup(p[1]);
      close(p[0]);
      close(p[1]);
      runcmd(pcmd->left);
    }
    if(fork1() == 0){
      close(0);
      dup(p[0]);
      close(p[0]);
      close(p[1]);
      runcmd(pcmd->right);
    }
    close(p[0]);
    close(p[1]);
    wait(0);
    wait(0);
    break;
```

xv6 的 shell 可以处理像 `grep fork sh.c | wc -l` 这样的命令，其中 `|` 表示管道。管道的作用是将一个命令的输出直接传递给下一个命令。

* **创建管道**：子进程先创建一个管道，用于连接两个命令。
* **执行命令**：然后，子进程会分别执行管道的左边和右边的命令，并且会等这两个命令都执行完成。

如果右边的命令又包含管道，比如 `a | b | c`，那么 shell 会再创建两个新的子进程来分别处理 `b` 和 `c`。这样，整个结构就形成了一棵**进程树**，最底下的节点是实际的命令，而上面的节点则是用来等待它们完成的进程。

**管道的优点**

1. **自动清理**：使用管道后，系统会自动处理相关资源的清理，而临时文件需要手动删除。
2. **数据流长**：管道可以处理任意长度的数据流，而临时文件的存储空间有限，需要保证磁盘上有足够的空间。
3. **并行执行**：管道可以让多个命令同时执行，而使用临时文件时，必须等第一个命令完成后，第二个命令才能开始执行。

#### 4. File system <a href="#xp1u5" id="xp1u5"></a>

文件和目录结构：xv6 文件系统将数据文件和目录组织成树状结构，根目录为起点。路径可以是绝对路径（以 / 开头）或相对路径（相对于当前目录）。

```
mkdir("/dir");
fd = open("/dir/file", O_CREATE|O_WRONLY);
close(fd);
mknod("/console", 1, 1);
```

`mknod("/console", 1, 1)`：创建一个名为 /console 的设备文件。mknod 的两个参数 1, 1 分别是主设备号和次设备号，用于唯一标识内核设备。

***

**设备文件的作用**

**设备文件**：设备文件是特殊类型的文件，用于与硬件设备进行交互。它们通过主设备号和次设备号唯一标识。

**系统调用重定向**：当进程打开设备文件时，内核会将读写系统调用重定向到相应的内核设备实现，而不是传递给文件系统。**这意味着对设备文件的操作实际上是在与硬件设备进行交互。**

***

**inode**

文件的名称与文件本身是不同的；同一个底层文件（称为 inode）可以有多个名称（称为链接）。每个链接由目录中的一个条目组成；该条目包含文件名和对 inode 的引用。inode 保存文件的元数据，包括其类型（文件、目录或设备）、长度、文件内容在磁盘上的位置以及文件的链接数。

```
#define T_DIR 1 // 目录
#define T_FILE 2 // 文件
#define T_DEVICE 3 // 设备

struct stat {
    int dev;       // 文件系统的磁盘设备
    uint ino;      // inode 号
    short type;    // 文件类型
    short nlink;   // 文件的链接数
    uint64 size;   // 文件大小（字节）
};
```

**文件名与 inode**：文件名只是对文件的引用，实际文件由 inode 表示。一个 inode 可以有多个文件名（链接）。

**inode 的元数据：**&#x69;node 包含文件的元数据，如类型、长度、磁盘位置和链接数。

**fstat 系统调用：**&#x66;stat 用于从 inode 中检索文件信息，并填充 struct stat 结构体。

**创建链接：**`link` 系统调用创建一个新的文件名，引用相同的 inode。读取或写入任一文件名都会影响相同的底层文件内容。

```
open("a", O_CREATE|O_WRONLY);
link("a", "b");

读取或写入 a 与读取或写入 b 是相同的。
每个 inode 由唯一的 inode 号标识。
执行上述代码序列后，
可以通过检查 fstat 的结果确定 a 和 b 引用相同的底层内容：
两者将返回相同的 inode 号（ino），并且 nlink 计数将设置为 2。
```

**删除链接**：unlink 系统调用删除文件名。当文件的链接数为零且没有文件描述符引用它时，inode 和磁盘空间才会被释放。

**临时文件：**&#x521B;建临时文件的一种常见方法是打开文件后立即删除其名称，这样文件在进程关闭文件描述符或退出时会被自动清理。

```
fd = open("/tmp/xyz", O_CREATE|O_RDWR);
unlink("/tmp/xyz");
```

***

Unix 设计了一些文件操作命令，如 mkdir（创建目录）、ln（创建链接）和 rm（删除文件），作为用户级程序。这意味着这些命令是独立于内核的，可以由用户在命令行中调用。而其它系统通常将这些命令内置 shell 中，甚至将 shell 内置内核中。

这种设计的好处是灵活性高，用户可以轻松地扩展命令行接口，添加新的命令和功能。

cd 命令是一个例外，它必须内置在 shell 中。原因是 cd 需要更改 shell 本身的当前工作目录。

为什么 cd 会内置在 shell 中呢？我们假设 cd 作为常规命令运行，shell 会创建一个子进程，子进程运行 cd 并更改其工作目录，但父进程（即 shell）的工作目录不会改变。这就达不到预期的效果。

在 Unix 中，每个进程都有自己的当前工作目录。cd 命令需要直接影响 shell 进程的工作目录，因此必须内置在 shell 中，而不是作为独立的用户级程序运行。

#### 5. Exercises <a href="#hrrcp" id="hrrcp"></a>

Write a program that uses UNIX system calls to “ping-pong” a byte between two processes over a pair of pipes, one for each direction. Measure the program’s performance, in ex changes per second.

```
#include "kernel/types.h"
#include "user/user.h"
int main(int argc, char const *argv[])
{
    int p2c[2], c2p[2];
    pipe(p2c);
    pipe(c2p);
    char buff[4];

    if (fork() == 0) { // child
        close(c2p[0]); //close p2c read;
        write(c2p[1],"pong",4);
        close(c2p[1]); //close p2c write;

        close(p2c[1]);//close write;
        read(p2c[0],buff,4);
        printf("%d received %s\n",getpid(),buff);
        close(p2c[0]);


    } else { // parent
        close(p2c[0]); //close p2c read;
        write(p2c[1],"ping",4);
        close(p2c[1]); //close p2c write;

        close(c2p[1]);//close write;
        read(c2p[0],buff,4);
        printf("%d received %s\n",getpid(),buff);
        close(c2p[0]);
    }
}
```

### (二) **LEC 1 (rtm):** Introduction and examples <a href="#x52xm" id="x52xm"></a>

#### 1. Userspace与 Kernel <a href="#yiwuf" id="yiwuf"></a>

用户空间（Userspace）就是操作系统中让用户可以运行应用程序的地方。它和内核空间（Kernel Space）分开，内核空间是操作系统核心功能运行的地方，比如管理硬件和资源。用户空间的应用程序无法直接访问硬件或内核数据，这样保证了系统的稳定性和安全性。可以看作是一个保护层，确保我们的操作不会破坏系统。

用户空间的一个好例子就是你正在使用的应用程序：浏览器、文字处理软件等等，它们都在用户空间内运行。

Kernel程序只有一个，它维护数据来管理每一个用户空间进程。Kernel同时还维护了大量的数据结构来帮助它管理各种各样的硬件资源，以供用户空间的程序使用。Kernel同时还有大量内置的服务，例如，Kernel通常会有文件系统实现类似文件名，文件内容，目录的东西，并理解如何将文件存储在磁盘中。所以用户空间的程序会与Kernel中的文件系统交互，文件系统再与磁盘交互。

**内核（Kernel）**&#x5C31;像是操作系统的大脑。它负责管理所有的用户空间程序（这些程序被称为进程），确保每个进程都有它需要的内存和CPU时间。内核还会复用和分配内存，确保系统资源得到最佳利用。

**文件系统**好比一个超级整理员。它负责管理所有的文件，知道文件的内容和它们在磁盘上的具体位置。它还能维护一个独立的命名空间，就像一个有层级的目录，每个目录中包含一些文件，保证文件井然有序。

**访问控制（Access Control）**&#x5219;是系统的安全守卫。它决定哪些进程可以访问哪些资源，确保进程不能随意读取或修改不该接触的内容，保障系统的安全。。

#### 2. 常见系统调用 <a href="#deofr" id="deofr"></a>

**read**接收三个参数：

* 第一个参数是**文件描述符**，指向之前打开的文件。文件描述符0默认连接到控制台的输入（即我们输入的内容），而文件描述符1连接到控制台的输出（即我们看到的打印输出）。所以，程序启动时，你输入的内容会通过文件描述符0读取，而程序的输出会通过文件描述符1显示。
* 第二个参数是一个**指针**，指向一块内存区域。这个指针就像一个地址，告诉程序数据要放在哪里。在代码的第10行，程序在栈里分配了64字节的内存，并把这个地址保存在buf变量中。所以，当使用read函数时，数据会被存到这64字节的内存中。
* 第三个参数是想要读取的**最大字节数**。这里的sizeof(buf)表示最多读取64字节的数据。因此，read函数最多能从文件描述符0（连接到控制台的输入）中读取64字节的数据。
* 简单来说，read函数会从控制台读取最多64字节的数据，并存到程序分配的内存中，通过文件描述符和指针来管理这些数据。

**Exit** ：形式：`int exit(int status)`。让调用它的进程停止执行并且将内存等占用的资源全部释放。需要一个整数形式的状态参数，0代表以正常状态退出，1代表以非正常状态退出

### (三) LAB 1 <a href="#ty8zb" id="ty8zb"></a>

According to the mit's passage, we have install the enviroment in our device. So, now we start to do labs.

Note: you should read the peoblems catiously, don't forget add \[$U/\_sleep\\] in Makefile

```
//
// Created by liulch on 24-10-13.
//
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int
main(int argc, char *argv[]){
  if ( argc == 1 ){
    printf("Usage: sleep is error, could't find any argv\n");
    exit(1);
    }
    int time = atoi(argv[1]);
    if (time < 0){
      printf("Invalid sleep value\n");
      exit(1);
    }

    sleep(time);

    exit(0);
}
```

#### 1. find (moderate) <a href="#zws4p" id="zws4p"></a>

这里要求我们首先去阅读 ls 的源码才能完成这个任务

## Lec03 <a href="#txtey" id="txtey"></a>

操作系统需要支持多个活动，例如 fork 的时候，操作系统需要在这些进程之间分配计算机资源。即使在进程数大于 CPU 数的情况下。此外为了一个进程出现 Bug 不会影响其他进程。操作系统必须满足三个条件：多路复用、隔离和交互。

## 一、操作系统组织 <a href="#u78yz" id="u78yz"></a>

### (一) 抽象物理资源 <a href="#gb1gc" id="gb1gc"></a>

操作系统（OS）存在的原因是为了提供一个抽象层，便于管理和使用硬件资源，并且能够在多个应用程序之间提供隔离和管理。尽管可以将系统调用实现为一个库，但这种方法在多任务和安全性方面存在一些不足。

#### 1. 操作系统提供的好处 <a href="#id-88c51609" id="id-88c51609"></a>

1. **资源管理与抽象**：

*
  * **文件系统**：OS将存储设备抽象为文件系统，应用程序通过`open`、`read`、`write`和`close`等系统调用与文件交互，而不是直接操作磁盘。这为应用程序提供了路径名的便利，并使操作系统能够管理磁盘。
  * **CPU调度**：OS透明地在进程之间切换硬件CPU，保存和恢复寄存器状态，允许多个应用程序共享CPU，即使某些应用程序陷入无限循环。
  * **内存管理**：通过`exec`系统调用来构建进程的内存映像，允许OS决定进程在内存中的位置，还能在内存紧张时将一些数据存储到磁盘。

2. **隔离与安全**：

*
  * 为了实现强隔离，OS禁止应用程序直接访问敏感硬件资源，而是将这些资源抽象为服务。
  * 例如，Unix应用程序通过文件系统的系统调用与存储交互，而不是直接读写磁盘。这提供了更好的安全性和隔离。
  * 应用程序间的交互通过文件描述符进行，这不仅抽象了许多细节，还简化了交互。例如，管道中的一个应用程序发生故障，内核会为下一个进程生成文件结束信号。

3. **多任务处理**：

*
  * 如果使用库的方法，每个应用程序都必须定期放弃CPU，以便其他应用程序能够运行。这种协作式分时方案依赖于应用程序的相互信任和无bug，但这种情况不常见。
  * OS通过透明的进程调度，确保CPU资源被公平分配，即使某些应用程序运行时间很长或者出现问题。

尽管理论上可以用库来替代操作系统，但操作系统在资源管理、安全性、隔离、多任务处理等方面提供了更强的支持，且更易于应用程序开发和运行。

#### 2. 机器模式、监督模式和用户模式 <a href="#azch4" id="azch4"></a>

操作系统为了可以清理失败的应用程序并继续运行其他应用成熟。

1. **强隔离的重要性**：

*
  * 应用程序不能直接修改或读取操作系统的数据结构和指令，也不能访问其他进程的内存。这可以防止一个应用程序的错误影响整个系统或其他应用程序。

2. **CPU 的硬件支持**：

*
  * 例如，RISC-V CPU 提供了机器模式、监督模式和用户模式三种模式。
  * **机器模式**：具有完全权限，主要用于系统配置。CPU 启动时处于此模式，xv6 操作系统在执行几行代码后会切换到监督模式。
  * **监督模式**：允许执行特权指令，如启用/禁用中断和读写页表地址寄存器等。监督模式下的软件可以执行特权指令，被认为是运行在内核空间。
  * **用户模式**：应用程序只能执行普通指令，如数值运算,跳转命令 JRC 等，运行在用户空间。用户模式下应用程序尝试执行特权指令，CPU 不会执行该指令，而是切换到监督模式，以便监督模式代码终止该应用程序。

3. **用户模式与监督模式的转换**：

*
  * 当应用程序需要调用内核函数时，必须从用户模式切换到监督模式。CPU 提供特殊指令（如 RISC-V 的 `ecall`），将 CPU 从用户模式切换到监督模式，并在内核指定的入口点进入内核。
  * 切换到监督模式后，内核可以验证系统调用参数，检查操作权限，然后决定执行或拒绝操作。

4. **控制进入点的重要性**：

*
  * 控制进入监督模式的入口点对于内核安全至关重要。如果应用程序能决定入口点，那么恶意应用程序可能会绕过安全检查，直接进入内核，导致系统被破坏。

这些机制确保了操作系统的安全性和稳定性，使得即使在应用程序出错的情况下，系统也能正常运行和管理资源。

#### 3. 内核组织 <a href="#r6ys9" id="r6ys9"></a>

1. **单体内核 (Monolithic Kernel)**：

*
  * **定义**：整个操作系统都运行在内核空间，拥有所有的硬件访问权限，所有系统调用都在监督模式下执行。
  * **优点**：简化设计，方便操作系统不同部分的协同工作。例如，文件系统和虚拟内存系统可以共享一个缓冲区缓存。
  * **缺点**：复杂的交互可能导致错误，一旦在监督模式下发生错误，整个内核可能崩溃，导致计算机停止工作并需要重启。

2. **微内核 (Microkernel)**：

*
  * **定义**：将大部分操作系统功能移到用户模式，只保留少量关键功能在内核空间运行。
  * **优点**：减少在内核空间运行的代码量，从而降低错误风险。操作系统服务作为用户级进程运行，通过进程间通信机制进行交互。
  * **例子**：图2.1中，文件系统作为用户级进程运行，内核提供进程间通信机制，允许应用程序与文件服务器交互。
  * ![](https://cdn.nlark.com/yuque/0/2024/png/40540759/1729441459851-4a7c364d-4c0f-4c8d-8c2e-dd50c20673d9.png)

3. **现实应用**：

*
  * **单体内核**：例如，Linux的单体内核为操作系统密集型应用程序提供了高性能，因为内核子系统可以紧密集成。
  * **微内核**：例如，Minix、L4和QNX在嵌入式环境中应用广泛，L4的一个变种seL4可以验证其内存安全和其他安全属性。
  * **争论**：开发者对哪种组织方式更好有很多争论，没有明确的结论。更好取决于性能、代码大小、可靠性等方面的定义。

4. **核心思想**：

*
  * 微内核和单体内核操作系统共享许多关键思想：实现系统调用、使用页表、处理中断、支持进程、并发控制和实现文件系统等。本书关注这些核心思想。

5. **Xv6**：

*
  * **实现**：Xv6被实现为一个单体内核，内核接口对应操作系统接口，内核实现了完整的操作系统。由于提供的服务较少，内核较小，但从概念上讲是单体内核。

### (二) 进程 概述 <a href="#cin6m" id="cin6m"></a>

1. **进程隔离**：在xv6中，进程是隔离的基本单位，防止一个进程影响其他进程的内存、CPU、文件描述符等，防止破坏内核的隔离机制。内核用于实现进程的机制包括用户/监督模式标志、地址空间和线程的时间片切换。
2. **进程抽象**：进程为程序提供了一个独立的内存系统（地址空间）和一个独立的CPU执行环境，使程序看起来像运行在独立的机器上。进程抽象可以防止一个进程破坏或监听另一个进程的内存、CPU、文件描述符等资源。
3. **页表与地址空间**：

*
  * 使用硬件实现的页表为每个进程提供独立的地址空间。
  * RISC-V 页表将虚拟地址（RISC-V 指令操作的地址）映射到物理地址（CPU 发送到主存的地址）。
  * 每个进程维护一个独立的页表，定义其地址空间。

4. **内核状态**：

*
  * xv6为每个进程维护多个状态信息，存储在`struct proc`结构体中。
  * 包括页表、内核堆栈和运行状态等。用 `p->xxx` 表示 `proc` 结构体的元素，例如 `p->pagetable` 是指向进程页表的指针。

5. **线程和堆栈**：

*
  * 每个进程有一个控制线程，保存执行进程所需的状态。
  * 线程可能在CPU上执行或挂起。
  * 每个进程有两个堆栈：用户堆栈和内核堆栈。执行用户指令时使用用户堆栈，进入内核时使用内核堆栈。
  * 当进程执行用户指令时，仅使用其用户堆栈，内核堆栈为空。
  * 当进程进入内核（进行系统调用或中断）时，内核代码在进程的内核堆栈上执行；当进程在内核中时，其用户堆栈仍包含保存的数据，但不被积极使用。
  * 进程的线程在使用其用户堆栈和内核堆栈之间交替。内核堆栈是独立的（并受到用户代码保护），即使进程破坏了其用户堆栈，内核也能执行。

6. **系统调用**：

*
  * 通过执行RISC-V `ecall`指令发起系统调用，提高硬件特权级别，将程序计数器更改为内核定义的入口点，入口点代码切换到进程的内核堆栈并执行实现系统调用的内核命令。
  * 系统调用完成时，内核切换回用户堆栈并通过调用 `sret` 指令返回用户空间，该指令降低硬件特权级别并恢复执行紧接系统调用指令之后的用户指令。进程的线程可以在内核中“阻塞”以等待 I/O，当 I/O 完成时从停止的位置恢复。

7. **进程状态**：

*
  * `p->state`指示进程的状态：已分配、准备运行、正在运行、等待I/O或退出。
  * `p->pagetable`保存进程的页表，用于记录进程内存的物理页面地址。

8. **总结**：

*
  * 进程结合了地址空间和线程两个设计理念，提供独立的内存和CPU假象。

### (三) 代码：启动 xv6、第一个进程和系统调用 <a href="#toqxa" id="toqxa"></a>

1. **RISC-V 计算机启动**：

*
  * 当 RISC-V 计算机启动时，它会初始化并运行存储在只读存储器（ROM）中的引导加载程序。
  * 引导加载程序的作用是将 xv6 内核从存储介质（例如硬盘）加载到内存中。

2. **内核加载与启动**：

*
  * 引导加载程序将 xv6 内核加载到物理地址 0x80000000。
  * 选择 0x80000000 而不是 0x0 的原因是地址范围 0x0 到 0x80000000 通常包含 I/O 设备，避免冲突。

3. **\_entry 函数**：

*
  * CPU 从 `_entry` 函数（kernel/entry.S:7）开始执行 xv6。
  * 由于 RISC-V 在启动时禁用分页硬件，虚拟地址直接映射到物理地址。
  * `_entry` 设置了一个堆栈，以便 xv6 可以运行 C 代码。具体来说，它加载了堆栈指针寄存器 `sp` 为 `stack0+4096`，即堆栈的顶部。

4. **start 函数**：

*
  * `_entry` 调用了 C 代码中的 `start` 函数（kernel/start.c:15）。
  * `start` 函数在机器模式下执行一些配置任务，这些任务只有在机器模式下才能完成。
  * 配置完成后，`start` 函数切换到监督模式，这通过 `mret` 指令实现。

5. **切换到监督模式**：

* 在切换到监督模式之前，`start` 函数进行了几项配置：
*
  * `start` 函数设置 `mstatus` 寄存器中的前一个特权模式为监督模式。这是为了确保当 `mret` 被执行时，CPU 知道要切换到监督模式。
  * 将 `main` 函数的地址写入 `mepc` 寄存器。
  * 禁用监督模式下的虚拟地址转换，通过将 0 写入 `satp` 寄存器实现的。这意味着监督模式下，虚拟地址直接映射到物理地址。
  * 将所有中断和异常委托给监督模式。
  * `start` 函数还配置时钟芯片生成定时器中断（这是为了确保系统定期终端执行，进行时间片轮转等任务管理）。

然后通过调用 `mret` 指令切换到监督模式（通常情况下`mret`指令被用于从监督模式返回机器模式）。

* `mret` 指令用于从机器模式切换到监督模式。它是通过读取 `mstatus` 寄存器中的前一个特权模式（已经被设置为监督模式）来确定切换的目标。
* 当 `mret` 被调用时，程序计数器（PC）会被设置为 `mepc` 寄存器中的值，这个值在之前已经被设定为 `main` 函数的地址。

**mstatus寄存器**：

`mstatus` 是 RISC-V 中的机器状态寄存器，其中包含当前和先前的特权模式等关键信息。

它记录了当前和之前的 CPU 特权级别，控制 CPU 的特权模式切换行为。

**mret指令**：

`mret` 指令用于从机器模式返回到之前的特权模式。

当执行 `mret` 时，CPU 会检查 `mstatus` 寄存器中的前一个特权模式字段，然后切换到该模式。

**特权模式切换**：

在 `start` 函数中，设置 `mstatus` 的前一个特权模式为监督模式（即使没有真正从监督模式返回），是为了欺骗 `mret` 指令，使其在执行时切换到监督模式。

`mepc` 寄存器设置为 `main` 函数的地址，以确保在切换到监督模式后，CPU 将从 `main` 函数开始执行。

**mepc（机器异常程序计数器）**：

* **功能**：`mepc` 寄存器用于存储在发生异常或中断时的程序计数器（PC）值。
* **内容**：当发生异常或系统调用时，当前的程序计数器值会被保存到 `mepc` 寄存器中，以便异常处理程序完成后能够恢复到原来的执行点。
* **作用**：当执行 `mret` 指令时，程序计数器（PC）会被设置为 `mepc` 寄存器的值，以恢复到中断或异常发生之前的执行点。

6. **main 函数**：

*
  * 程序计数器（PC）跳转到 `main` 函数（kernel/main.c:11）。
  * `main` 函数初始化了几个设备和子系统，然后调用 `userinit`（kernel/proc.c:233）创建第一个进程。

7. **创建第一个进程**：

*
  * 第一个进程执行一个用 RISC-V 汇编编写的小程序，这个程序进行了 xv6 中的第一次系统调用。
  * `initcode.S`（user/initcode.S:3）将 `exec` 系统调用的编号 `SYS_EXEC`（kernel/syscall.h:8）加载到寄存器 `a7`，然后调用 `ecall` 重新进入内核。

8. **执行系统调用**：

*
  * 内核使用寄存器 `a7` 中的编号在 `syscall`（kernel/syscall.c:132）中调用所需的系统调用。
  * 系统调用表（kernel/syscall.c:107）将 `SYS_EXEC` 映射到函数 `sys_exec`，然后内核调用该函数。
  * `exec` 系统调用用新程序（本例中为 `/init`）替换当前进程的内存和寄存器。

9. **初始化用户空间**：

*
  * 内核完成 `exec` 后，返回到用户空间的 `/init` 进程。
  * `init`（user/init.c:15）创建新的控制台设备文件（如果需要），然后将其作为文件描述符 0、1 和 2 打开。最后，它在控制台上启动一个 shell，完成系统启动。

### (四) 安全模式 <a href="#hys0x" id="hys0x"></a>

**用户代码可能从以下几种途径来对系统内核和其他进程造成破坏：**

* 用户代码可能会尝试在其允许的地址空间之外解引用指针；
* 尝试执行任何RISC-V指令，甚至是那些不打算用于用户代码的指令；
* 尝试读取和写入任何RISC-V控制寄存器；
* 试图直接访问设备硬件；
* 通过系统调用传递巧妙的值以试图使内核崩溃或做一些愚蠢的事情。

**内核目标：**

内核的目标是限制每个用户进程，使其只能读取/写入/执行自己的用户内存，使用32个通用的RISC-V寄存器，并以系统调用预期允许的方式影响内核和其他进程。内核必须防止任何其他操作。

**保障措施：**

值得在内核中设计保障措施，以防它有漏洞：例如，断言、类型检查、堆栈保护页等。最后，用户代码和内核代码之间的区别有时会变得模糊：一些特权用户级进程可能提供重要服务并实际上成为操作系统的一部分，并且在某些操作系统中，特权用户代码可以将新代码插入内核（如Linux的可加载内核模块）。

### (五) 3.1 操作系统的隔离性 <a href="#id-3.1-cao-zuo-xi-tong-de-ge-li-xing" id="id-3.1-cao-zuo-xi-tong-de-ge-li-xing"></a>

缺失了操作系统，应用程序会直接与硬件交互。例如：用户空间有多个应用程序，比如LShell，echo，find。而我们运行这些程序将会出现这么几个问题：

* Shell运行A代码的时出错可能会影响到其他应用程序。
* 使用操作系统的一个目的是为了同时运行多个应用程序，所以时不时的，CPU会从一个应用程序切换到另一个应用程序。 CPU会从一个应用程序切换到另一个应用程序，没有操作系统，所以需要应用程序Shell释放资源。
* Shell运行了一段时间之后，需要让别的程序也有机会能运行。 这种机制有时候称为协同调度（Cooperative Scheduling）。但是在这里Shell中的某个函数有一个死循环，那么Shell永远也不会释放CPU，进而其他的应用程序也不能够运行，甚至都不能运行一个第三方的程序来停止或者杀死Shell程序。所以这种场景下，我们基本上得不到真正的multiplexing（CPU在多进程同分时复用。
* 内存角度来讲，应用程序如果直接运行在硬件程序上，每个程序直接保存在物理内存。应用程序可能会没有边界感。例如：内存地址1000存储了echo的数据，但是Shell可能将其覆盖。 ![](https://cdn.nlark.com/yuque/0/2024/png/40540759/1731938325757-a802fb8f-6960-46bb-a34c-a1c9504b0cbe.png)

我们使用操作系统最主要的原因就是为了实现 **multiplexing** 和 **内存隔离** 。但是不通过操作系统，应用程序直接与硬件交互，很难实现这点。所以，除了实时操作系统有将操作系统设计为库的设计，因为实时操作系统中，应用程序彼此之间相互信任，大部分操作系统都会强制实现硬件资源隔离。

Unix接口通过抽象硬件资源，从而提供强隔离性，实现资源的强隔离，也就是multiplexing和物理内存的隔离。

举几个例子：

应用程序不能直接与CPU交互，只能与进程交互，操作系统内核会完成不同进程在CPU上的切换。进程抽象了CPU,操作系统才能在多个应用程序之间分时复用多个CPU。

exec抽象内存。当我们执行exec系统调用时候，我们会传入一个文件名，这个文件名对应一个应用程序的内存镜像。内存镜像中包括程序的对应指令和全局数据。应用程序可以（比如说sbrk命令通过扩展数据段）扩展自己的内存，但是不能直接访问物理内存，操作系统会提供内存隔离并控制内存，操作系统会在应用程序和硬件资源之间提供一个中间层。

files时Unix中应用程序与存储系统交互的唯一方式，files提供了非常方便的磁盘抽象，可以对文件命名，读写文件等等。Files提供了磁盘抽象，我们可以对文件命名，读写文件等等。之后，操作系统会决定如何将文件与磁盘中的块对应，确保一个磁盘块只出现在一个文件中，并且确保用户A不能操作用户B的文件。通过files的抽象，可以实现不同用户之间和同一个用户的不同进程之间的文件强隔离。

3.2 操作系统的防御性

操作系统需要去抵御应用程序的攻击，如果应用程序无意，恶意的向系统调用传入一些错误参数会导致操作系统的崩溃，而导致操作系统无法向所有应用程序提供服务。

同时，应用程序也不能打破隔离，进而控制内核。一旦控制了内核，可以做任何事情，因为内核控制了所有硬件程序。

这意味着我们需要在应用程序和操作系统之间提供强隔离性。如果操作系统需要具备防御性，那么在应用程序和操作系统之间需要有一堵厚墙，并且操作系统可以在这堵墙上执行任何它想执行的策略。

。这里的硬件支持包括了两部分，第一部分是user/kernel mode（在RISC-V中被称为Supervisor mode）；第二部分是page table或者虚拟内存（Virtual Memory）。

所有的处理器，如果需要运行能够支持多个应用程序的操作系统，需要同时支持user/kernle mode和虚拟内存。具体的实现或许会有细微的差别，但是基本上来说所有的处理器需要能支持这些。

3.3硬件对于强隔离支持

为了支持user/kernel mode，处理器会有两种操作模式：

user mode ： CPU只能运行普通权限的指令（unprivileged instructions）。比如：ADD 、 SUB、JRC（跳转）、BRANCH

kernel mode ：CPU可以运行特定权限的指令（privileged instructions）。privileged instructions指的是：直接操纵硬件的指令和设置保护的指令，例如设置page table寄存器、关闭时钟中断

实际上RISC-V还有第三种模式称为machine mode。在大多数场景下，我们会忽略这种模式，所以我也不太会介绍这种模式。 所以实际上我们有三级权限（user/kernel/machine），而不是两级(user/kernel)。

当一个应用程序尝试执行一条特殊权限指令，因为不允许在user mode执行特殊权限指令，处理器会拒绝执行这条指令。通常来说，这时会将控制权限从user mode切换到kernel mode，当操作系统拿到控制权之后，或许会杀掉进程，因为应用程序执行了不该执行的指令。

如何实现在user mode 和 kernel mode的切换？

在处理器里面有一个flag。在处理器的一个bit，当它为1的时候是user mode，当它为0时是kernel mode。当处理器在解析指令时，如果指令是特殊权限指令，并且该bit被设置为1，处理器会拒绝执行这条指令/

我们可以认为User/kernel mode是分隔用户空间和内核空间的边界，用户空间的程序运行在user mode，内核空间的程序运行在kernel mode。

User Mode和Kernel Mode的关系大致如下：

3.4 宏内核VS微内核

我们可以通过系统调用或者ECALL指令，将控制权从应用程序转到操作系统中。内核负责实现的具体功能并且检查参数，防止而已参数。内核因此也被称为TCB（Trusted Computing Base）。
