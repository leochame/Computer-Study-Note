# Lec07 驱动程序与中断机制

## **硬件部分**

**网卡收到packpage,网卡就会产生中断，按下键盘也会产生中断。**

**如果受到一个中断，sw save its work, process interupt, resume its work。它和page fasult,syscall都使用了相同的机制。**

**中断和系统调用有3个差别：**

* **asychronous: 硬件生成中断的时候，interupt handler与当前运行的进程在CPU上没有任何关联。但是如果是系统调用，系统调用发生在运行进程的context下。**
* concurrency：CPU和生成中断的设备是并行的运行。网卡自己独立处理来自网络的packet,然后在某个时间点产生中断。但是同时，CPU也是在运行。所以我们在CPU和设备之间是真正的并行，我们必须管理这里的并行。
* program device。我们需要主要关注外部设备，例如网卡，UART，而这些设备需要被编程。

&#x20;&#x20;

w

所有的设备都连接到处理器上，处理器上是通过Platform Level Interrupt Control，简称PLIC来处理设备中断









## **驱动程序与中断概述**

* **驱动程序**：负责管理和控制特定硬件设备的代码，处理硬件与操作系统之间的交互。包括配置设备硬件、指示设备执行操作、处理硬件中断等。驱动程序与它管理的设备并发执行，驱动程序还必须理解设备的硬件接口。
* **硬件中断**：硬件设备通过中断通知CPU自己完成了一项操作，要求操作系统处理相应的任务。设备可能会产生输入中断（如键盘输入）或输出中断（如输出完成）。
* **中断处理流程**：
  1. 设备生成中断信号。
  2. 操作系统trap handler程序捕捉中断信号，识别中断源。
  3. 调用对应的中断服务例程（ISR）处理设备相关的任务。

**2. 中断处理与设备交互**

* **设备驱动的上下文**：
  * **上半部**：由系统调用触发（如`read`、`write`），用于发起设备操作，如请求硬件读取数据。
  * **下半部**：设备中断服务程序，硬件操作完成后触发，唤醒一个等待的进程，并告知硬件开始执行任何等待的下一个操作。
* **控制台驱动（`console.c`）**：
  * **输入**：通过串口设备（UART硬件）从键盘接收用户输入。
  * **输出**：通过串口设备（UART硬件）将字符输出到显示屏。
  * 输入时，操作系统通过中断机制接收键盘输入，并通过中断触发执行`consoleintr`函数，缓冲输入，等待完成后交给上层进程。输出时，通过`uartputc`写字符到缓冲区，依赖中断将数据逐步送到设备进行显示。

**3. UART硬件接口**

* **UART (Universal Asynchronous Receiver/Transmitter)**：串行通信接口，用于接收和发送数据。
  * **内存映射寄存器**：UART硬件通过特定的内存地址与软件交互。
    * LSR寄存器：指示是否有待读取的数据。
    * RHR寄存器：接收数据。
    * THR寄存器：发送数据。
  * UART可以通过硬件中断生成输入中断（数据到达）和输出中断（数据发送完成）。
* **UART控制寄存器**：
  * 配置UART工作模式，触发输入输出中断。
  * 在`consoleinit`中初始化UART设备，使其能够响应中断。
* **操作流程**：
  1. `consoleinit`初始化UART硬件，配置中断。
  2. 设备触发中断（例如，用户输入时触发接收中断）。
  3. 中断处理程序（如`uartintr`）处理接收的数据，传递给控制台驱动（`consoleintr`），最终将数据传递给进程。

**4. 控制台驱动的输入与输出**

* **输入（`console.c`）**：
  * 当用户输入字符时，字符通过硬件中断传输到`uartintr`，然后通过`consoleintr`传递给进程。
  * 进程通过`read`系统调用读取缓冲区中的数据。
  * `consoleintr`负责将输入数据缓存在`cons.buf`中，直到输入行完成。
  * 如果缓冲区满，进程会通过`sleep`等待，直到完整的一行输入到达。
* **输出（`uart.c`）**：
  * 当用户通过`write`系统调用输出数据时，`uartputc`会将字符加入输出缓冲区。
  * 如果输出缓冲区已满，`uartputc`会等待；否则，会启动输出过程。
  * 输出过程通过中断逐个发送字符，直到缓冲区为空。

**5. 中断与进程并发**

* **中断并发性问题**：
  * 两个不同的CPU可能同时访问设备，产生并发问题。
  * 设备中断可能会打断正在执行的进程，需要通过锁（如`acquire`）保护共享资源，确保中断处理程序和上层进程之间不会出现数据竞争。
* **锁的使用**：
  * 驱动程序中的数据结构（如控制台缓冲区）需要加锁保护，避免在并发处理中出现错误。
  * 中断处理程序通常不涉及复杂操作，而是将数据缓存在缓冲区并唤醒等待的进程。

**6. 定时器中断**

* **定时器中断**：xv6使用定时器中断来实现时间管理和进程调度。
  * 定时器中断来自RISC-V CPU的时钟硬件，通过中断触发操作系统进行时间管理。
  * 在每个CPU上定期触发中断，维护`ticks`变量，用于跟踪时间。
  * 定时器中断还用于进程调度，允许操作系统在多个进程间进行CPU时间分配。
* **定时器中断的处理**：
  1. 定时器中断通过`usertrap`或`kerneltrap`传递给`devintr`。
  2. `devintr`调用`clockintr`，更新时间，并检查是否需要唤醒等待进程。
  3. 通过`stimecmp`寄存器安排下一次定时器中断。

**7. 操作系统中的设备支持**

* **设备种类繁多**：设备驱动程序的复杂性随着设备种类的增加而增加。不同类型的设备（如硬盘、网络接口、显示器等）需要不同的驱动程序和硬件接口。
* **驱动程序代码量**：在大多数操作系统中，驱动程序代码占据了内核代码的很大一部分。对于支持多种硬件的系统，驱动程序的实现可能会相当庞大。

**8. 练习与扩展**

* **练习1**：修改`uart.c`，不使用中断，改为轮询模式。这将涉及将输入数据直接从UART寄存器读取，而不通过中断来触发输入。
* **练习2**：为xv6添加一个以太网卡驱动程序，涉及网络数据包的接收和发送，以及相应的网络中断处理。

#### 总结

xv6通过硬件中断机制与设备进行交互，控制台设备驱动程序（`console.c`）与UART硬件实现用户输入输出。中断服务程序通过`uartintr`和`consoleintr`处理输入输出数据，并通过缓冲机制解耦设备和进程操作，提升系统并发性和响应速度。定时器中断和进程调度机制进一步增强了操作系统的多任务处理能力。



