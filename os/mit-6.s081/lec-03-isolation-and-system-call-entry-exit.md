# Lec 03

操作系统需要支持多个活动，例如 fork 的时候，操作系统需要在这些进程之间分配计算机资源。即使在进程数大于 CPU 数的情况下。此外为了一个进程出现 Bug 不会影响其他进程。操作系统必须满足三个条件：多路复用、隔离和交互。

## 一、操作系统组织 <a href="#u78yz" id="u78yz"></a>

### (一) 抽象物理资源 <a href="#gb1gc" id="gb1gc"></a>

操作系统（OS）存在的原因是为了提供一个抽象层，便于管理和使用硬件资源，并且能够在多个应用程序之间提供隔离和管理。尽管可以将系统调用实现为一个库，但这种方法在多任务和安全性方面存在一些不足。

#### 1.操作系统提供的好处

1. **资源管理与抽象**：

* **文件系统**：OS将存储设备抽象为文件系统，应用程序通过`open`、`read`、`write`和`close`等系统调用与文件交互，而不是直接操作磁盘。这为应用程序提供了路径名的便利，并使操作系统能够管理磁盘。
* **CPU调度**：OS透明地在进程之间切换硬件CPU，保存和恢复寄存器状态，允许多个应用程序共享CPU，即使某些应用程序陷入无限循环。
* **内存管理**：通过`exec`系统调用来构建进程的内存映像，允许OS决定进程在内存中的位置，还能在内存紧张时将一些数据存储到磁盘。

2. **隔离与安全**：

* 为了实现强隔离，OS禁止应用程序直接访问敏感硬件资源，而是将这些资源抽象为服务。
* 例如，Unix应用程序通过文件系统的系统调用与存储交互，而不是直接读写磁盘。这提供了更好的安全性和隔离。
* 应用程序间的交互通过文件描述符进行，这不仅抽象了许多细节，还简化了交互。例如，管道中的一个应用程序发生故障，内核会为下一个进程生成文件结束信号。

3. **多任务处理**：

* 如果使用库的方法，每个应用程序都必须定期放弃CPU，以便其他应用程序能够运行。这种协作式分时方案依赖于应用程序的相互信任和无bug，但这种情况不常见。
* OS通过透明的进程调度，确保CPU资源被公平分配，即使某些应用程序运行时间很长或者出现问题。

尽管理论上可以用库来替代操作系统，但操作系统在资源管理、安全性、隔离、多任务处理等方面提供了更强的支持，且更易于应用程序开发和运行。

#### 2. 机器模式、监督模式和用户模式 <a href="#azch4" id="azch4"></a>

操作系统为了可以清理失败的应用程序并继续运行其他应用成熟。

1. **强隔离的重要性**：

* 应用程序不能直接修改或读取操作系统的数据结构和指令，也不能访问其他进程的内存。这可以防止一个应用程序的错误影响整个系统或其他应用程序。

2. **CPU 的硬件支持**：

* 例如，RISC-V CPU 提供了机器模式、监督模式和用户模式三种模式。
* **机器模式**：具有完全权限，主要用于系统配置。CPU 启动时处于此模式，xv6 操作系统在执行几行代码后会切换到监督模式。
* **监督模式**：允许执行特权指令，如启用/禁用中断和读写页表地址寄存器等。监督模式下的软件可以执行特权指令，被认为是运行在内核空间。
* **用户模式**：应用程序只能执行普通指令，如数值运算,跳转命令 JRC 等，运行在用户空间。用户模式下应用程序尝试执行特权指令，CPU 不会执行该指令，而是切换到监督模式，以便监督模式代码终止该应用程序。

3. **用户模式与监督模式的转换**：

* 当应用程序需要调用内核函数时，必须从用户模式切换到监督模式。CPU 提供特殊指令（如 RISC-V 的 `ecall`），将 CPU 从用户模式切换到监督模式，并在内核指定的入口点进入内核。
* 切换到监督模式后，内核可以验证系统调用参数，检查操作权限，然后决定执行或拒绝操作。

4. **控制进入点的重要性**：

* 控制进入监督模式的入口点对于内核安全至关重要。如果应用程序能决定入口点，那么恶意应用程序可能会绕过安全检查，直接进入内核，导致系统被破坏。

这些机制确保了操作系统的安全性和稳定性，使得即使在应用程序出错的情况下，系统也能正常运行和管理资源。

#### 3. 内核组织 <a href="#r6ys9" id="r6ys9"></a>

1. **宏内核 (Monolithic Kernel)**：

* **定义**：整个操作系统都运行在内核空间，拥有所有的硬件访问权限，所有系统调用都在监督模式下执行。
* **优点**：简化设计，方便操作系统不同部分的协同工作。例如，文件系统和虚拟内存系统可以共享一个缓冲区缓存。
* **缺点**：复杂的交互可能导致错误，一旦在监督模式下发生错误，整个内核可能崩溃，导致计算机停止工作并需要重启。

2. **微内核 (Microkernel)**：

* **定义**：将大部分操作系统功能移到用户模式，只保留少量关键功能在内核空间运行。
* **优点**：减少在内核空间运行的代码量，从而降低错误风险。操作系统服务作为用户级进程运行，通过进程间通信机制进行交互。
* **例子**：图2.1中，文件系统作为用户级进程运行，内核提供进程间通信机制，允许应用程序与文件服务器交互。

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

3. **现实应用**：

* **单体内核**：例如，Linux的单体内核为操作系统密集型应用程序提供了高性能，因为内核子系统可以紧密集成。
* **微内核**：例如，Minix、L4和QNX在嵌入式环境中应用广泛，L4的一个变种seL4可以验证其内存安全和其他安全属性。
* **争论**：开发者对哪种组织方式更好有很多争论，没有明确的结论。更好取决于性能、代码大小、可靠性等方面的定义。

4. **核心思想**：

* 微内核和单体内核操作系统共享许多关键思想：实现系统调用、使用页表、处理中断、支持进程、并发控制和实现文件系统等。本书关注这些核心思想。

5. **Xv6**：

* **实现**：Xv6被实现为一个单体内核，内核接口对应操作系统接口，内核实现了完整的操作系统。由于提供的服务较少，内核较小，但从概念上讲是单体内核。

### (二) 进程 概述 <a href="#cin6m" id="cin6m"></a>

1. **进程隔离**：在xv6中，进程是隔离的基本单位，防止一个进程影响其他进程的内存、CPU、文件描述符等，防止破坏内核的隔离机制。内核用于实现进程的机制包括用户/监督模式标志、地址空间和线程的时间片切换。
2. **进程抽象**：进程为程序提供了一个独立的内存系统（地址空间）和一个独立的CPU执行环境，使程序看起来像运行在独立的机器上。进程抽象可以防止一个进程破坏或监听另一个进程的内存、CPU、文件描述符等资源。
3. **页表与地址空间**：

* 使用硬件实现的页表为每个进程提供独立的地址空间。
* RISC-V 页表将虚拟地址（RISC-V 指令操作的地址）映射到物理地址（CPU 发送到主存的地址）。
* 每个进程维护一个独立的页表，定义其地址空间。

4. **内核状态**：

* xv6为每个进程维护多个状态信息，存储在`struct proc`结构体中。
* 包括页表、内核堆栈和运行状态等。用 `p->xxx` 表示 `proc` 结构体的元素，例如 `p->pagetable` 是指向进程页表的指针。

5. **线程和堆栈**：

* 每个进程有一个控制线程，保存执行进程所需的状态。
* 线程可能在CPU上执行或挂起。
* 每个进程有两个堆栈：用户堆栈和内核堆栈。执行用户指令时使用用户堆栈，进入内核时使用内核堆栈。
* 当进程执行用户指令时，仅使用其用户堆栈，内核堆栈为空。
* 当进程进入内核（进行系统调用或中断）时，内核代码在进程的内核堆栈上执行；当进程在内核中时，其用户堆栈仍包含保存的数据，但不被积极使用。
* 进程的线程在使用其用户堆栈和内核堆栈之间交替。内核堆栈是独立的（并受到用户代码保护），即使进程破坏了其用户堆栈，内核也能执行。

6. **系统调用**：

* 通过执行RISC-V `ecall`指令发起系统调用，提高硬件特权级别，将程序计数器更改为内核定义的入口点，入口点代码切换到进程的内核堆栈并执行实现系统调用的内核命令。
* 系统调用完成时，内核切换回用户堆栈并通过调用 `sret` 指令返回用户空间，该指令降低硬件特权级别并恢复执行紧接系统调用指令之后的用户指令。进程的线程可以在内核中“阻塞”以等待 I/O，当 I/O 完成时从停止的位置恢复。

7. **进程状态**：

* `p->state`指示进程的状态：已分配、准备运行、正在运行、等待I/O或退出。
* `p->pagetable`保存进程的页表，用于记录进程内存的物理页面地址。

8. **总结**：

* 进程结合了地址空间和线程两个设计理念，提供独立的内存和CPU假象。

### (三) 代码：启动 xv6、第一个进程和系统调用 <a href="#toqxa" id="toqxa"></a>

1. **RISC-V 计算机启动**：

* 当 RISC-V 计算机启动时，它会初始化并运行存储在只读存储器（ROM）中的引导加载程序。
* 引导加载程序的作用是将 xv6 内核从存储介质（例如硬盘）加载到内存中。

2. **内核加载与启动**：

* 引导加载程序将 xv6 内核加载到物理地址 0x80000000。
* 选择 0x80000000 而不是 0x0 的原因是地址范围 0x0 到 0x80000000 通常包含 I/O 设备，避免冲突。

3. **\_entry 函数**：

* CPU 从 `_entry` 函数（kernel/entry.S:7）开始执行 xv6。
* 由于 RISC-V 在启动时禁用分页硬件，虚拟地址直接映射到物理地址。
* `_entry` 设置了一个堆栈，以便 xv6 可以运行 C 代码。具体来说，它加载了堆栈指针寄存器 `sp` 为 `stack0+4096`，即堆栈的顶部。

4. **start 函数**：

* `_entry` 调用了 C 代码中的 `start` 函数（kernel/start.c:15）。
* `start` 函数在机器模式下执行一些配置任务，这些任务只有在机器模式下才能完成。
* 配置完成后，`start` 函数切换到监督模式，这通过 `mret` 指令实现。

5. **切换到监督模式**：

* 在切换到监督模式之前，`start` 函数进行了几项配置：
  * `start` 函数设置 `mstatus` 寄存器中的前一个特权模式为监督模式。这是为了确保当 `mret` 被执行时，CPU 知道要切换到监督模式。
  * 将 `main` 函数的地址写入 `mepc` 寄存器。
  * 禁用监督模式下的虚拟地址转换，通过将 0 写入 `satp` 寄存器实现的。这意味着监督模式下，虚拟地址直接映射到物理地址。
  * 将所有中断和异常委托给监督模式。
  * `start` 函数还配置时钟芯片生成定时器中断（这是为了确保系统定期终端执行，进行时间片轮转等任务管理）。

然后通过调用 `mret` 指令切换到监督模式（通常情况下`mret`指令被用于从监督模式返回机器模式）。

* `mret` 指令用于从机器模式切换到监督模式。它是通过读取 `mstatus` 寄存器中的前一个特权模式（已经被设置为监督模式）来确定切换的目标。
* 当 `mret` 被调用时，程序计数器（PC）会被设置为 `mepc` 寄存器中的值，这个值在之前已经被设定为 `main` 函数的地址。

**mstatus寄存器**：

`mstatus` 是 RISC-V 中的机器状态寄存器，其中包含当前和先前的特权模式等关键信息。

它记录了当前和之前的 CPU 特权级别，控制 CPU 的特权模式切换行为。

**mret指令**：

`mret` 指令用于从机器模式返回到之前的特权模式。

当执行 `mret` 时，CPU 会检查 `mstatus` 寄存器中的前一个特权模式字段，然后切换到该模式。

**特权模式切换**：

在 `start` 函数中，设置 `mstatus` 的前一个特权模式为监督模式（即使没有真正从监督模式返回），是为了欺骗 `mret` 指令，使其在执行时切换到监督模式。

`mepc` 寄存器设置为 `main` 函数的地址，以确保在切换到监督模式后，CPU 将从 `main` 函数开始执行。

**mepc（机器异常程序计数器）**：

* **功能**：`mepc` 寄存器用于存储在发生异常或中断时的程序计数器（PC）值。
* **内容**：当发生异常或系统调用时，当前的程序计数器值会被保存到 `mepc` 寄存器中，以便异常处理程序完成后能够恢复到原来的执行点。
* **作用**：当执行 `mret` 指令时，程序计数器（PC）会被设置为 `mepc` 寄存器的值，以恢复到中断或异常发生之前的执行点。

6. **main 函数**：

* 程序计数器（PC）跳转到 `main` 函数（kernel/main.c:11）。
* `main` 函数初始化了几个设备和子系统，然后调用 `userinit`（kernel/proc.c:233）创建第一个进程。

7. **创建第一个进程**：

* 第一个进程执行一个用 RISC-V 汇编编写的小程序，这个程序进行了 xv6 中的第一次系统调用。
* `initcode.S`（user/initcode.S:3）将 `exec` 系统调用的编号 `SYS_EXEC`（kernel/syscall.h:8）加载到寄存器 `a7`，然后调用 `ecall` 重新进入内核。

8. **执行系统调用**：

* 内核使用寄存器 `a7` 中的编号在 `syscall`（kernel/syscall.c:132）中调用所需的系统调用。
* 系统调用表（kernel/syscall.c:107）将 `SYS_EXEC` 映射到函数 `sys_exec`，然后内核调用该函数。
* `exec` 系统调用用新程序（本例中为 `/init`）替换当前进程的内存和寄存器。

9. **初始化用户空间**：

* 内核完成 `exec` 后，返回到用户空间的 `/init` 进程。
* `init`（user/init.c:15）创建新的控制台设备文件（如果需要），然后将其作为文件描述符 0、1 和 2 打开。最后，它在控制台上启动一个 shell，完成系统启动。

### (四) 安全模式 <a href="#hys0x" id="hys0x"></a>

**用户代码可能从以下几种途径来对系统内核和其他进程造成破坏：**

* 用户代码可能会尝试在其允许的地址空间之外解引用指针；
* 尝试执行任何RISC-V指令，甚至是那些不打算用于用户代码的指令；
* 尝试读取和写入任何RISC-V控制寄存器；
* 试图直接访问设备硬件；
* 通过系统调用传递巧妙的值以试图使内核崩溃或做一些愚蠢的事情。

**内核目标：**

内核的目标是限制每个用户进程，使其只能读取/写入/执行自己的用户内存，使用32个通用的RISC-V寄存器，并以系统调用预期允许的方式影响内核和其他进程。内核必须防止任何其他操作。

**保障措施：**

值得在内核中设计保障措施，以防它有漏洞：例如，断言、类型检查、堆栈保护页等。最后，用户代码和内核代码之间的区别有时会变得模糊：一些特权用户级进程可能提供重要服务并实际上成为操作系统的一部分，并且在某些操作系统中，特权用户代码可以将新代码插入内核（如Linux的可加载内核模块）。



***

## LEC

### 3.1 操作系统的隔离性 <a href="#ujq7n" id="ujq7n"></a>

缺失了操作系统，应用程序会直接与硬件交互。例如：用户空间有多个应用程序，比如LShell，echo，find。而我们运行这些程序将会出现这么几个问题：

* Shell运行A代码的时出错可能会影响到其他应用程序。
* 使用操作系统的一个目的是为了同时运行多个应用程序，所以时不时的，CPU会从一个应用程序切换到另一个应用程序。 CPU会从一个应用程序切换到另一个应用程序，没有操作系统，所以需要应用程序Shell释放资源。
* Shell运行了一段时间之后，需要让别的程序也有机会能运行。 这种机制有时候称为协同调度（Cooperative Scheduling）。但是在这里Shell中的某个函数有一个死循环，那么Shell永远也不会释放CPU，进而其他的应用程序也不能够运行，甚至都不能运行一个第三方的程序来停止或者杀死Shell程序。所以这种场景下，我们基本上得不到真正的multiplexing（CPU在多进程同分时复用。
* 内存角度来讲，应用程序如果直接运行在硬件程序上，每个程序直接保存在物理内存。应用程序可能会没有边界感。例如：内存地址1000存储了echo的数据，但是Shell可能将其覆盖。

<figure><img src="../../.gitbook/assets/image (3) (1).png" alt="" width="256"><figcaption></figcaption></figure>

我们使用操作系统最主要的原因就是为了实现 **multiplexing** 和 **内存隔离** 。但是不通过操作系统，应用程序直接与硬件交互，很难实现这点。所以，除了实时操作系统有将操作系统设计为库的设计，因为实时操作系统中，应用程序彼此之间相互信任，大部分操作系统都会强制实现硬件资源隔离。

Unix接口通过抽象硬件资源，从而提供强隔离性，实现资源的强隔离，也就是multiplexing和物理内存的隔离。

举几个例子：

应用程序不能直接与CPU交互，只能与进程交互，操作系统内核会完成不同进程在CPU上的切换。进程抽象了CPU,操作系统才能在多个应用程序之间分时复用多个CPU。

exec抽象内存。当我们执行exec系统调用时候，我们会传入一个文件名，这个文件名对应一个应用程序的内存镜像。内存镜像中包括程序的对应指令和全局数据。应用程序可以（比如说sbrk命令通过扩展数据段）扩展自己的内存，但是不能直接访问物理内存，操作系统会提供内存隔离并控制内存，操作系统会在应用程序和硬件资源之间提供一个中间层。

files时Unix中应用程序与存储系统交互的唯一方式，files提供了非常方便的磁盘抽象，可以对文件命名，读写文件等等。Files提供了磁盘抽象，我们可以对文件命名，读写文件等等。之后，操作系统会决定如何将文件与磁盘中的块对应，确保一个磁盘块只出现在一个文件中，并且确保用户A不能操作用户B的文件。通过files的抽象，可以实现不同用户之间和同一个用户的不同进程之间的文件强隔离。

### 3.2 操作系统的防御性

操作系统需要去抵御应用程序的攻击，如果应用程序无意，恶意的向系统调用传入一些错误参数会导致操作系统的崩溃，而导致操作系统无法向所有应用程序提供服务。

同时，应用程序也不能打破隔离，进而控制内核。一旦控制了内核，可以做任何事情，因为内核控制了所有硬件程序。

这意味着我们需要在应用程序和操作系统之间提供强隔离性。如果操作系统需要具备防御性，那么在应用程序和操作系统之间需要有一堵厚墙，并且操作系统可以在这堵墙上执行任何它想执行的策略。

。这里的硬件支持包括了两部分，第一部分是user/kernel mode（在RISC-V中被称为Supervisor mode）；第二部分是page table或者虚拟内存（Virtual Memory）。

所有的处理器，如果需要运行能够支持多个应用程序的操作系统，需要同时支持user/kernle mode和虚拟内存。具体的实现或许会有细微的差别，但是基本上来说所有的处理器需要能支持这些。

### 3.3硬件对于强隔离支持

为了支持user/kernel mode，处理器会有两种操作模式：

user mode ： CPU只能运行普通权限的指令（unprivileged instructions）。比如：ADD 、 SUB、JRC（跳转）、BRANCH

kernel mode ：CPU可以运行特定权限的指令（privileged instructions）。privileged instructions指的是：直接操纵硬件的指令和设置保护的指令，例如设置page table寄存器、关闭时钟中断

实际上RISC-V还有第三种模式称为machine mode。在大多数场景下，我们会忽略这种模式，所以我也不太会介绍这种模式。 所以实际上我们有三级权限（user/kernel/machine），而不是两级(user/kernel)。

当一个应用程序尝试执行一条特殊权限指令，因为不允许在user mode执行特殊权限指令，处理器会拒绝执行这条指令。通常来说，这时会将控制权限从user mode切换到kernel mode，当操作系统拿到控制权之后，或许会杀掉进程，因为应用程序执行了不该执行的指令。

如何实现在user mode 和 kernel mode的切换？

在处理器里面有一个flag。在处理器的一个bit，当它为1的时候是user mode，当它为0时是kernel mode。当处理器在解析指令时，如果指令是特殊权限指令，并且该bit被设置为1，处理器会拒绝执行这条指令/

我们可以认为User/kernel mode是分隔用户空间和内核空间的边界，用户空间的程序运行在user mode，内核空间的程序运行在kernel mode。

User Mode和Kernel Mode的关系大致如下：

### 3.4 宏内核VS微内核

我们可以通过系统调用或者ECALL指令，将控制权从应用程序转到操作系统中。内核负责实现的具体功能并且检查参数，防止而已参数。内核因此也被称为TCB（Trusted Computing Base,可信任的計算空間）。 &#x20;

那么应该什么程序运行在kernel mode？有两种选项：

* 整个操作系统运行在kernel mode，称为Monolithic Kernel Design（宏内核）。
* kernel mode下尽可能少的运行代码，称为Micro Kernel Design（微内核）。&#x20;

宏内核的话，主要两点：

* 在宏内核中，任何一个操作系统Bug都有可能导致漏洞，在内核中运行一个巨大的操作系统，出Bug的可能性会更大。内核中拥有大量代码是宏内核的缺点。
* 如果你去看一个操作系统，包含了各种各样的组成部分，包括文件系统，虚拟内存，进程管理等特定功能的子模块。宏内核的优势是将这些子模块集成在一个程序之中了，会提供很好的性能。

而微内核就弥补了宏内核的缺陷，但是出现了内核模块少的缺点：  &#x20;

* 内核通常会有些IPC（Inter-Process Communication，进程间的通信）的实现或者是Message passing；非常少的虚拟内存支持，可能只支持了page table；以及分时复用CPU的支持。
* 微内核的目的是将大部分的操作系统运行在内核外，还是会有user mode以及user/kernel mode的边界。但是会将原来在内核中的其他部分，作为普通的用户程序来运行。比如，echo，Shell，sh或者虚拟内存的一部分也会以一个普通应用程序形式运行在user mode。

但是微内核就会引出一个经典的进程通信，进程共享的问题。



#### 微内核带来的进程通信问题：

如Shell调用了exec，必须有种方式可以接入到文件系统中。通常来说，这里工作的方式是，Shell会通过内核中的IPC系统发送一条消息，内核会查看这条消息并发现这是给文件系统的消息，之后内核会把消息发送给文件系统。

<figure><img src="../../.gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

文件系统会完成它的工作之后会向IPC系统发送回一条消息说，这是你的exec系统调用的结果，之后IPC系统再将这条消息发送给Shell。

这是一个典型的通过消息来实现传统的系统调用。现在，对于任何文件系统的交互，都需要分别完成2次用户空间<->内核空间的跳转。与宏内核对比，在宏内核中如果一个应用程序需要与文件系统交互，只需要完成1次用户空间<->内核空间的跳转，所以微内核的的跳转是宏内核的两倍。通常微内核的挑战在于性能更差。

1. 在user/kernel mode反复跳转带来的性能损耗。
2. 在一个类似宏内核的紧耦合系统，各个组成部分，例如文件系统和虚拟内存系统，可以很容易的共享page cache。而在微内核中，每个部分之间都很好的隔离开了，这种共享更难实现。进而导致更难在微内核中得到更高的性能。

## 3.5 编译运行Kernel

来介绍下，xv6是怎么工作的：

首先看下代码结构，代码主要分为三部分：

* kernel。里面包含了基本上所有的内核文件。因为XV6是一个宏内核结构，这里所有的文件会被编译成一个叫做kernel的二进制文件，然后这个二进制文件会被运行在kernle mode中。
* user。这基本上是运行在user mode的程序。这也是为什么一个目录称为kernel，另一个目录称为user的原因。
* mkfs。它会创建一个空的文件镜像，我们会将这个镜像存在磁盘上，这样我们就可以直接使用一个空的文件系统。

接下来看内核的编译过程：

{% stepper %}
{% step %}
Makefile（XV6目录下的文件）会读取一个C文件，例如proc.c
{% endstep %}

{% step %}
调用gcc编译器，生成一个文件叫做proc.s，这是RISC-V 汇编语言文件
{% endstep %}

{% step %}
走到汇编解释器，生成proc.o，这是汇编语言的二进制格式。
{% endstep %}

{% step %}
Makefile会为所有内核文件做相同的操作，比如说pipe.c，会按照同样的套路，先经过gcc编译成pipe.s，再通过汇编解释器生成pipe.o
{% endstep %}

{% step %}
系统加载器（Loader）会收集所有的.o文件，将它们链接在一起，并生成内核文件。
{% endstep %}
{% endstepper %}

这里生成的内核文件就是我们将会在QEMU中运行的文件。同时，为了你们的方便，Makefile还会创建kernel.asm，这里包含了内核的完整汇编语言，你们可以通过查看它来定位究竟是哪个指令导致了Bug。

内核默认任何程序的起点都是80000.

我们来看传给QEMU的几个参数：

* -kernel：这里传递的是内核文件（kernel目录下的kernel文件），这是将在QEMU中运行的程序文件。
* -m：这里传递的是RISC-V虚拟机将会使用的内存数量
* -smp：这里传递的是虚拟机可以使用的CPU核数
* -drive：传递的是虚拟机使用的磁盘驱动，这里传入的是fs.img文件

设置好这样QEMU就像一台真正的计算机了。这样，XV6系统就在QEMU中启动了。

## 3.6 QUME

实际上抛开一些细节，通过QEMU模拟的计算机系统或者说计算机主板，与这里由SiFive生产的计算机主板非常相似。本来想给你们展示一下这块主板的，但是我刚刚说过它在我的办公室，而我已经很久没去过办公室了，或许它已经吃了很多灰了。当你们在运行QEMU时，你们需要知道，你们基本上跟在运行硬件是一样的，只是说同样的东西，QEMU在软件中实现了而已。

当我们说QEMU仿真了RISC-V处理器时，背后的含义是什么？

直观来看，QEMU是一个大型的开源C程序，你可以下载或者git clone它。但是在内部，在QEMU的主循环中，只在做一件事情：

* 读取4字节或者8字节的RISC-V指令。
* 解析RISC-V指令，并找出对应的操作码（op code）。我们之前在看kernel.asm的时候，看过一些操作码的二进制版本。通过解析，或许可以知道这是一个ADD指令，或者是一个SUB指令。
* 之后，在软件中执行相应的指令。

这基本上就是QEMU的全部工作了，对于每个CPU核，QEMU都会运行这么一个循环。

为了完成这里的工作，QEMU的主循环需要维护寄存器的状态。所以QEMU会有以C语言声明的类似于X0，X1寄存器等等。

当QEMU在执行一条指令，比如(ADD a0, 7, 1)，这里会将常量7和1相加，并将结果存储在a0寄存器中，所以在这个例子中，寄存器X0会是7。

之后QEMU会执行下一条指令，并持续不断的执行指令。除了仿真所有的普通权限指令之外，QEMU还会仿真所有的特殊权限指令，这就是QEMU的工作原理。对于你们来说，你们只需要认为你们跑在QEMU上的代码跟跑在一个真正的RISC-V处理器上是一样的，就像你们在6.004这门课程中使用过的RISC-V处理器一样。\
&#x20;&#x20;

## LAB

为了完成这个LAB我们首先要明白用户调用如何传递到内核中 `exec` 系统调用的实现。

1. **初始化系统调用参数**：
   * `initcode.S` 文件中的代码通过将 `exec` 系统调用的参数分别放入寄存器 `a0` 和 `a1`，并将系统调用号放入 `a7`，来准备调用。
   * 系统调用号与内核中的 `syscalls` 数组中的函数指针对应。
2. **陷入内核**：
   * 执行 `ecall` 指令后，系统会陷入内核模式。
   * 在内核模式下，会执行 `uservec`、`usertrap` 和 `syscall` 函数，处理该系统调用。
3. **检索系统调用号**：
   * `syscall` 函数从 `trapframe` 中的 `a7` 寄存器中检索到系统调用号。
   * 这个系统调用号用于索引 `syscalls` 数组，以找到对应的系统调用处理函数。
4. **执行系统调用**：
   * 对于第一个系统调用，`a7` 中的值是 `SYS_exec`，对应于 `sys_exec` 函数。
   * 内核调用 `sys_exec` 函数来执行 `exec` 系统调用。
5. **记录返回值**：
   * 当 `sys_exec` 函数返回时，`syscall` 函数将其返回值记录在 `p->trapframe->a0` 中。
   * 由于 RISC-V 的 C 调用约定返回值放在 `a0` 中，这样原始用户空间的 `exec()` 调用就能返回这个值。
6. **错误处理**：
   * 系统调用通常返回负数表示错误，返回零或正数表示成功。
   * 如果系统调用号无效，`syscall` 会打印错误信息并返回 -1。

通过这些步骤，用户空间的系统调用能够被正确传递到内核进行处理，并且返回结果到用户空间。这种机制确保了系统调用的正确执行和返回值的传递。



如何在内核实现系统调用时，找到并处理用户代码传递的参数。以下是逐步解释：

1. **系统调用参数传递**：
   * 用户代码通过调用系统调用包装函数传递参数，这些参数最初存储在 RISC-V C 调用约定定义的寄存器中。
   * 内核陷阱代码将用户寄存器保存到当前进程的陷阱帧中，内核代码可以在此处找到这些参数。
2. **检索系统调用参数**：
   * 内核函数 `argint`、`argaddr` 和 `argfd` 从陷阱帧中检索第 n 个系统调用参数，并将其作为整数、指针或文件描述符返回。
   * 这些函数都调用 `argraw` 来检索适当的保存用户寄存器。
3. **处理指针参数**：
   * 有些系统调用传递指针作为参数，内核必须使用这些指针读取或写入用户内存。例如，`exec` 系统调用传递一个指针数组，引用用户空间中的字符串参数。
   * 处理这些指针有两个挑战：
     1. 用户程序可能有错误或恶意，可能会传递无效指针或企图欺骗内核访问内核内存而非用户内存。
     2. xv6 内核页表映射与用户页表映射不同，内核不能使用普通指令从用户提供的地址加载或存储数据。
4. **安全数据传输函数**：
   * 内核实现了一些函数，用于安全地在用户提供的地址和内核之间传输数据。例如，`fetchstr` 函数用于从用户空间检索字符串文件名参数。
   * `fetchstr` 调用 `copyinstr` 来完成实际的工作。
5. **copyinstr 函数**：
   * `copyinstr` 从用户页表 `pagetable` 中的虚拟地址 `srcva` 复制最多 `max` 字节到目标地址 `dst`。由于 `pagetable` 不是当前页表，`copyinstr` 使用 `walkaddr`（调用 `walk`）来查找 `srcva`，生成物理地址 `pa0`。
   * 内核页表将所有物理内存映射到等于物理地址的虚拟地址。这使得 `copyinstr` 可以直接从 `pa0` 复制字符串字节到 `dst`。
6. **walkaddr 函数**：
   * `walkaddr` 检查用户提供的虚拟地址是否属于进程的用户地址空间，因此程序无法欺骗内核读取其他内存。
   * 类似的函数 `copyout` 用于将数据从内核复制到用户提供的地址。

这段文字解释了系统调用参数传递和处理的机制，包括如何在内核中安全地读取和写入用户内存。内核通过保存用户寄存器、检索系统调用参数、处理指针参数和实现安全数据传输函数，确保系统调用的安全和正确执行。这些机制确保内核在处理用户请求时不会被恶意或错误的用户代码欺骗。\
\
\
\
理解这个LAB的要求

让我为你详细解释一下 `trace` 的用法和它在示例中的作用。

#### trace 的用法

1.  **基本用法**：

    ```sh
    trace mask command
    ```

    * **mask**：跟踪掩码，指定要跟踪哪些系统调用。它是一个整数，其位表示要跟踪的系统调用。例如，`1 << SYS_read` 表示跟踪 `read` 系统调用。
    * **command**：要运行的命令，在该命令执行期间，系统调用会被跟踪并记录。
2.  **示例用法**：

    ```sh
    trace 32 grep hello README
    ```

    这条命令的作用是：

    * **32**：这是一个掩码，具体来说是 `1 << SYS_read`。表示要跟踪 `read` 系统调用。
    * **grep hello README**：这是要运行的命令，`grep` 用于在 `README` 文件中搜索包含 “hello” 的行。

#### 示例输出解析

当你运行 `trace 32 grep hello README` 时，程序的行为如下：

1. **trace 工具启动**：`trace` 工具启动并设置跟踪掩码。掩码 `32` 表示只跟踪 `read` 系统调用。
2. **执行 grep 命令**：`trace` 工具启动并执行 `grep hello README` 命令。
3. **系统调用跟踪**：
   * 在 `grep` 命令执行过程中，每次 `read` 系统调用被触发时，`trace` 工具会记录相关信息。
   * 记录的信息包括进程 ID、系统调用的名称（`read`）和返回值。

例如，终端输出如下：

```plaintext
$ trace 32 grep hello README
3: syscall read -> 1023
3: syscall read -> 966
3: syscall read -> 70
3: syscall read -> 0
$
```

* **3**：这是进程 ID。
* **syscall read**：表示这是一个 `read` 系统调用。
* **-> 1023**、**-> 966**、**-> 70**、**-> 0**：这些是 `read` 系统调用的返回值。

通过这些输出，你可以看到 `grep` 命令在执行过程中每次 `read` 系统调用的详细信息。这对于调试和分析程序行为非常有帮助。

#### 更多示例

1.  **跟踪所有系统调用**：

    ```sh
    trace 2147483647 grep hello README
    ```

    这里的 `2147483647` 是一个掩码，设置了所有 31 个低位，表示跟踪所有系统调用。
2.  **跟踪 fork 系统调用**：

    ```sh
    trace 2 usertests forkforkfork
    ```

    这里的 `2` 表示跟踪 `fork` 系统调用。`usertests forkforkfork` 是要运行的命令。



\




## What you should do before you do lab.









